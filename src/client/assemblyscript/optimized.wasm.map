{"version":3,"sources":["~lib/internal/allocator.ts","~lib/allocator/arena.ts","~lib/internal/arraybuffer.ts","~lib/internal/string.ts","~lib/internal/typedarray.ts","~lib/memory.ts","~lib/internal/memory.ts","assembly/index.ts","~lib/typedarray.ts","~lib/builtins.ts"],"names":[],"mappings":"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","sourceRoot":"assemblyscript:///","sourceContents":["/** Number of alignment bits. */\r\n@inline export const AL_BITS: u32 = 3;\r\n/** Number of possible alignment values. */\r\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\r\n/** Mask to obtain just the alignment bits. */\r\n@inline export const AL_MASK: usize = AL_SIZE - 1;\r\n/** Maximum 32-bit allocation size. */\r\n@inline export const MAX_SIZE_32: usize = 1 << 30; // 1GB\r\n","/**\r\n * Arena Memory Allocator\r\n *\r\n * Provides a `memory.reset` function to reset the heap to its initial state. A user has to make\r\n * sure that there are no more references to cleared memory afterwards. Always aligns to 8 bytes.\r\n *\r\n * @module std/assembly/allocator/arena\r\n *//***/\r\n\r\nimport { AL_MASK, MAX_SIZE_32 } from \"../internal/allocator\";\r\n\r\nvar startOffset: usize = (HEAP_BASE + AL_MASK) & ~AL_MASK;\r\nvar offset: usize = startOffset;\r\n\r\n// Memory allocator interface\r\n\r\n@global export function __memory_allocate(size: usize): usize {\r\n  if (size > MAX_SIZE_32) unreachable();\r\n  var ptr = offset;\r\n  var newPtr = (ptr + max<usize>(size, 1) + AL_MASK) & ~AL_MASK;\r\n  var pagesBefore = memory.size();\r\n  if (newPtr > <usize>pagesBefore << 16) {\r\n    let pagesNeeded = ((newPtr - ptr + 0xffff) & ~0xffff) >>> 16;\r\n    let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\r\n    if (memory.grow(pagesWanted) < 0) {\r\n      if (memory.grow(pagesNeeded) < 0) {\r\n        unreachable(); // out of memory\r\n      }\r\n    }\r\n  }\r\n  offset = newPtr;\r\n  return ptr;\r\n}\r\n\r\n@global export function __memory_free(ptr: usize): void { /* nop */ }\r\n\r\n@global export function __memory_reset(): void {\r\n  offset = startOffset;\r\n}\r\n","import {\r\n  AL_MASK,\r\n  MAX_SIZE_32\r\n } from \"./allocator\";\r\n\r\n/** Size of an ArrayBuffer header. */\r\n@inline export const HEADER_SIZE: usize = (offsetof<ArrayBuffer>() + AL_MASK) & ~AL_MASK;\r\n/** Maximum byte length of an ArrayBuffer. */\r\n@inline export const MAX_BLENGTH: i32 = <i32>MAX_SIZE_32 - HEADER_SIZE;\r\n\r\nfunction computeSize(byteLength: i32): usize {\r\n  // round up to power of 2, with HEADER_SIZE=8:\r\n  // 0            -> 2^3  = 8\r\n  // 1..8         -> 2^4  = 16\r\n  // 9..24        -> 2^5  = 32\r\n  // ...\r\n  // MAX_LENGTH   -> 2^30 = 0x40000000 (MAX_SIZE_32)\r\n  return <usize>1 << <usize>(<u32>32 - clz<u32>(byteLength + HEADER_SIZE - 1));\r\n}\r\n\r\n// Low-level utility\r\n\r\nfunction __gc(ref: usize): void {}\r\n\r\nexport function allocateUnsafe(byteLength: i32): ArrayBuffer {\r\n  assert(<u32>byteLength <= <u32>MAX_BLENGTH);\r\n  var buffer: usize;\r\n  if (isManaged<ArrayBuffer>()) {\r\n    buffer = __gc_allocate(computeSize(byteLength), __gc); // tslint:disable-line\r\n  } else {\r\n    buffer = memory.allocate(computeSize(byteLength));\r\n  }\r\n  store<i32>(buffer, byteLength, offsetof<ArrayBuffer>(\"byteLength\"));\r\n  return changetype<ArrayBuffer>(buffer);\r\n}\r\n\r\nexport function reallocateUnsafe(buffer: ArrayBuffer, newByteLength: i32): ArrayBuffer {\r\n  var oldByteLength = buffer.byteLength;\r\n  if (newByteLength > oldByteLength) {\r\n    assert(newByteLength <= MAX_BLENGTH);\r\n    if (newByteLength <= <i32>(computeSize(oldByteLength) - HEADER_SIZE)) { // fast path: zero out additional space\r\n      store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>(\"byteLength\"));\r\n    } else { // slow path: copy to new buffer\r\n      let newBuffer = allocateUnsafe(newByteLength);\r\n      memory.copy(\r\n        changetype<usize>(newBuffer) + HEADER_SIZE,\r\n        changetype<usize>(buffer) + HEADER_SIZE,\r\n        <usize>oldByteLength\r\n      );\r\n      if (!isManaged<ArrayBuffer>()) {\r\n        memory.free(changetype<usize>(buffer));\r\n      }\r\n      buffer = newBuffer;\r\n    }\r\n    memory.fill(\r\n      changetype<usize>(buffer) + HEADER_SIZE + <usize>oldByteLength,\r\n      0,\r\n      <usize>(newByteLength - oldByteLength)\r\n    );\r\n  } else if (newByteLength < oldByteLength) { // fast path: override size\r\n    // TBD: worth to copy and release if size is significantly less than before?\r\n    assert(newByteLength >= 0);\r\n    store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>(\"byteLength\"));\r\n  }\r\n  return buffer;\r\n}\r\n\r\n// The helpers below use two different types in order to emit loads and stores that load respectively\r\n// store one type to/from memory while returning/taking the desired output/input type. This allows to\r\n// emit instructions like\r\n//\r\n// * `i32.load8` ^= `<i32>load<i8>(...)` that reads an i8 but returns an i32, or\r\n// * `i64.load32_s` ^= `<i64>load<i32>(...)`) that reads a 32-bit as a 64-bit integer\r\n//\r\n// without having to emit an additional instruction for conversion purposes. The second parameter\r\n// can be omitted for references and other loads and stores that simply return the exact type.\r\n\r\n@inline export function LOAD<T,TOut = T>(buffer: ArrayBuffer, index: i32, byteOffset: i32 = 0): TOut {\r\n  return <TOut>load<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()) + <usize>byteOffset, HEADER_SIZE);\r\n}\r\n\r\n@inline export function STORE<T,TIn = T>(buffer: ArrayBuffer, index: i32, value: TIn, byteOffset: i32 = 0): void {\r\n  store<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()) + <usize>byteOffset, value, HEADER_SIZE);\r\n}\r\n","import { MAX_SIZE_32 } from \"./allocator\";\r\nimport { String } from \"../string\";\r\n\r\n/** Size of a String header. */\r\n@inline export const HEADER_SIZE = (offsetof<String>() + 1) & ~1; // 2 byte aligned\r\n/** Maximum length of a String. */\r\n@inline export const MAX_LENGTH = (<i32>MAX_SIZE_32 - HEADER_SIZE) >>> 1;\r\n\r\n// Low-level utility\r\n\r\nfunction __gc(ref: usize): void {}\r\n\r\nexport function allocateUnsafe(length: i32): String {\r\n  assert(length > 0 && length <= MAX_LENGTH);\r\n  var buffer: usize;\r\n  if (isManaged<String>()) {\r\n    buffer = __gc_allocate(HEADER_SIZE + (<usize>length << 1), __gc);  // tslint:disable-line\r\n  } else {\r\n    buffer = memory.allocate(HEADER_SIZE + (<usize>length << 1));\r\n  }\r\n  store<i32>(buffer, length);\r\n  return changetype<String>(buffer);\r\n}\r\n\r\n@inline\r\nexport function freeUnsafe(buffer: String): void {\r\n  if (!isManaged<String>()) {\r\n    assert(buffer);\r\n    memory.free(changetype<usize>(buffer));\r\n  }\r\n}\r\n\r\nexport function copyUnsafe(dest: String, destOffset: usize, src: String, srcOffset: usize, len: usize): void {\r\n  memory.copy(\r\n    changetype<usize>(dest) + (destOffset << 1) + HEADER_SIZE,\r\n    changetype<usize>(src)  + (srcOffset  << 1) + HEADER_SIZE,\r\n    len << 1\r\n  );\r\n}\r\n\r\nexport function compareUnsafe(str1: String, offset1: usize, str2: String, offset2: usize, len: usize): i32 {\r\n  var cmp: i32 = 0;\r\n  var ptr1 = changetype<usize>(str1) + (offset1 << 1);\r\n  var ptr2 = changetype<usize>(str2) + (offset2 << 1);\r\n  while (len && !(cmp = <i32>load<u16>(ptr1, HEADER_SIZE) - <i32>load<u16>(ptr2, HEADER_SIZE))) {\r\n    --len, ptr1 += 2, ptr2 += 2;\r\n  }\r\n  return cmp;\r\n}\r\n\r\nexport function repeatUnsafe(dest: String, destOffset: usize, src: String, count: i32): void {\r\n  var length = src.length;\r\n  if (ASC_SHRINK_LEVEL > 1) {\r\n    let strLen = length << 1;\r\n    let to   = changetype<usize>(dest) + HEADER_SIZE + (destOffset << 1);\r\n    let from = changetype<usize>(src)  + HEADER_SIZE;\r\n    for (let i = 0, len = strLen * count; i < len; i += strLen) {\r\n      memory.copy(to + i, from, strLen);\r\n    }\r\n  } else {\r\n    switch (length) {\r\n      case 0: break;\r\n      case 1: {\r\n        let cc =  load<u16>(changetype<usize>(src), HEADER_SIZE);\r\n        let out = changetype<usize>(dest) + (destOffset << 1);\r\n        for (let i = 0; i < count; ++i) {\r\n          store<u16>(out + (i << 1), cc, HEADER_SIZE);\r\n        }\r\n        break;\r\n      }\r\n      case 2: {\r\n        let cc  = load<u32>(changetype<usize>(src), HEADER_SIZE);\r\n        let out = changetype<usize>(dest) + (destOffset << 1);\r\n        for (let i = 0; i < count; ++i) {\r\n          store<u32>(out + (i << 2), cc, HEADER_SIZE);\r\n        }\r\n        break;\r\n      }\r\n      case 3: {\r\n        let cc1 = load<u32>(changetype<usize>(src), HEADER_SIZE + 0);\r\n        let cc2 = load<u16>(changetype<usize>(src), HEADER_SIZE + 4);\r\n        let out = changetype<usize>(dest) + (destOffset << 1);\r\n        for (let i = 0; i < count; ++i) {\r\n          store<u32>(out + (i << 2), cc1, HEADER_SIZE + 0);\r\n          store<u16>(out + (i << 1), cc2, HEADER_SIZE + 4);\r\n        }\r\n        break;\r\n      }\r\n      case 4: {\r\n        let cc = load<u64>(changetype<usize>(src), HEADER_SIZE);\r\n        let out = changetype<usize>(dest) + (destOffset << 1);\r\n        for (let i = 0; i < count; ++i) {\r\n          store<u64>(out + (i << 3), cc, HEADER_SIZE);\r\n        }\r\n        break;\r\n      }\r\n      default: {\r\n        let strLen = length << 1;\r\n        let to   = changetype<usize>(dest) + HEADER_SIZE + (destOffset << 1);\r\n        let from = changetype<usize>(src)  + HEADER_SIZE;\r\n        for (let i = 0, len = strLen * count; i < len; i += strLen) {\r\n          memory.copy(to + i, from, strLen);\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Helpers\r\n\r\n@inline export const enum CharCode {\r\n  PLUS = 0x2B,\r\n  MINUS = 0x2D,\r\n  DOT = 0x2E,\r\n  _0 = 0x30,\r\n  _1 = 0x31,\r\n  _2 = 0x32,\r\n  _3 = 0x33,\r\n  _4 = 0x34,\r\n  _5 = 0x35,\r\n  _6 = 0x36,\r\n  _7 = 0x37,\r\n  _8 = 0x38,\r\n  _9 = 0x39,\r\n  A = 0x41,\r\n  B = 0x42,\r\n  E = 0x45,\r\n  N = 0x4E,\r\n  O = 0x4F,\r\n  X = 0x58,\r\n  Z = 0x5a,\r\n  a = 0x61,\r\n  b = 0x62,\r\n  e = 0x65,\r\n  n = 0x6E,\r\n  o = 0x6F,\r\n  x = 0x78,\r\n  z = 0x7A\r\n}\r\n\r\nexport function isWhiteSpaceOrLineTerminator(c: u16): bool {\r\n  switch (c) {\r\n    case 9:    // <TAB>\r\n    case 10:   // <LF>\r\n    case 13:   // <CR>\r\n    case 11:   // <VT>\r\n    case 12:   // <FF>\r\n    case 32:   // <SP>\r\n    case 160:  // <NBSP>\r\n    case 8232: // <LS>\r\n    case 8233: // <PS>\r\n    case 65279: return true; // <ZWNBSP>\r\n    default: return false;\r\n  }\r\n}\r\n\r\n/** Parses a string to an integer (usually), using the specified radix. */\r\nexport function parse<T>(str: String, radix: i32 = 0): T {\r\n  var len: i32 = str.length;\r\n  if (!len) return <T>NaN;\r\n\r\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\r\n  var code = <i32>load<u16>(ptr, HEADER_SIZE);\r\n\r\n  // determine sign\r\n  var sign: T;\r\n  if (code == CharCode.MINUS) {\r\n    if (!--len) return <T>NaN;\r\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\r\n    sign = -1;\r\n  } else if (code == CharCode.PLUS) {\r\n    if (!--len) return <T>NaN;\r\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\r\n    sign = 1;\r\n  } else {\r\n    sign = 1;\r\n  }\r\n\r\n  // determine radix\r\n  if (!radix) {\r\n    if (code == CharCode._0 && len > 2) {\r\n      switch (<i32>load<u16>(ptr + 2, HEADER_SIZE)) {\r\n        case CharCode.B:\r\n        case CharCode.b: {\r\n          ptr += 4; len -= 2;\r\n          radix = 2;\r\n          break;\r\n        }\r\n        case CharCode.O:\r\n        case CharCode.o: {\r\n          ptr += 4; len -= 2;\r\n          radix = 8;\r\n          break;\r\n        }\r\n        case CharCode.X:\r\n        case CharCode.x: {\r\n          ptr += 4; len -= 2;\r\n          radix = 16;\r\n          break;\r\n        }\r\n        default: radix = 10;\r\n      }\r\n    } else radix = 10;\r\n  } else if (radix < 2 || radix > 36) {\r\n    return <T>NaN;\r\n  }\r\n\r\n  // calculate value\r\n  var num: T = 0;\r\n  while (len--) {\r\n    code = <i32>load<u16>(ptr, HEADER_SIZE);\r\n    if (code >= CharCode._0 && code <= CharCode._9) {\r\n      code -= CharCode._0;\r\n    } else if (code >= CharCode.A && code <= CharCode.Z) {\r\n      code -= CharCode.A - 10;\r\n    } else if (code >= CharCode.a && code <= CharCode.z) {\r\n      code -= CharCode.a - 10;\r\n    } else break;\r\n    if (code >= radix) break;\r\n    num = (num * radix) + code;\r\n    ptr += 2;\r\n  }\r\n  return sign * num;\r\n}\r\n","import {\r\n  HEADER_SIZE as AB_HEADER_SIZE,\r\n  MAX_BLENGTH as AB_MAX_BLENGTH,\r\n  allocateUnsafe,\r\n  LOAD,\r\n  STORE\r\n} from \"./arraybuffer\";\r\n\r\nimport {\r\n  SORT as SORT_IMPL\r\n} from \"./sort\";\r\n\r\n/** Typed array base class. Not a global object. */\r\nexport abstract class TypedArray<T> {\r\n  [key: number]: T; // compatibility only\r\n\r\n  readonly buffer: ArrayBuffer;\r\n  readonly byteOffset: i32;\r\n  readonly byteLength: i32;\r\n\r\n  constructor(length: i32) {\r\n    const MAX_LENGTH = <u32>AB_MAX_BLENGTH / sizeof<T>();\r\n    if (<u32>length > MAX_LENGTH) throw new RangeError(\"Invalid typed array length\");\r\n    var byteLength = length << alignof<T>();\r\n    var buffer = allocateUnsafe(byteLength);\r\n    memory.fill(changetype<usize>(buffer) + AB_HEADER_SIZE, 0, <usize>byteLength);\r\n    this.buffer = buffer;\r\n    this.byteOffset = 0;\r\n    this.byteLength = byteLength;\r\n  }\r\n\r\n  @inline\r\n  get length(): i32 {\r\n    return this.byteLength >>> alignof<T>();\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  protected __get(index: i32): T {\r\n    if (<u32>index >= <u32>(this.byteLength >>> alignof<T>())) throw new Error(\"Index out of bounds\");\r\n    return LOAD<T>(this.buffer, index, this.byteOffset);\r\n  }\r\n\r\n  @inline @operator(\"{}\")\r\n  protected __unchecked_get(index: i32): T {\r\n    return LOAD<T>(this.buffer, index, this.byteOffset);\r\n  }\r\n\r\n  @operator(\"[]=\")\r\n  protected __set(index: i32, value: native<T>): void {\r\n    if (<u32>index >= <u32>(this.byteLength >>> alignof<T>())) throw new Error(\"Index out of bounds\");\r\n    STORE<T,native<T>>(this.buffer, index, value, this.byteOffset);\r\n  }\r\n\r\n  @inline @operator(\"{}=\")\r\n  protected __unchecked_set(index: i32, value: native<T>): void {\r\n    STORE<T,native<T>>(this.buffer, index, value, this.byteOffset);\r\n  }\r\n\r\n  // copyWithin(target: i32, start: i32, end: i32 = this.length): this\r\n}\r\n\r\n@inline\r\nexport function FILL<TArray extends TypedArray<T>, T extends number>(\r\n  array: TArray,\r\n  value: native<T>,\r\n  start: i32,\r\n  end: i32\r\n): TArray {\r\n  var buffer = array.buffer;\r\n  var byteOffset = array.byteOffset;\r\n  var len = array.length;\r\n  start = start < 0 ? max(len + start, 0) : min(start, len);\r\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\r\n  if (sizeof<T>() == 1) {\r\n    if (start < end) {\r\n      memory.fill(\r\n        changetype<usize>(buffer) + start + byteOffset + AB_HEADER_SIZE,\r\n        <u8>value,\r\n        <usize>(end - start)\r\n      );\r\n    }\r\n  } else {\r\n    for (; start < end; ++start) {\r\n      STORE<T,native<T>>(buffer, start, value, byteOffset);\r\n    }\r\n  }\r\n  return array;\r\n}\r\n\r\n@inline\r\nexport function SORT<TArray extends TypedArray<T>, T>(\r\n  array: TArray,\r\n  comparator: (a: T, b: T) => i32\r\n): TArray {\r\n  var byteOffset = array.byteOffset;\r\n  var length = array.length;\r\n  if (length <= 1) return array;\r\n  var buffer = array.buffer;\r\n  if (length == 2) {\r\n    let a = LOAD<T>(buffer, 1, byteOffset);\r\n    let b = LOAD<T>(buffer, 0, byteOffset);\r\n    if (comparator(a, b) < 0) {\r\n      STORE<T>(buffer, 1, b, byteOffset);\r\n      STORE<T>(buffer, 0, a, byteOffset);\r\n    }\r\n    return array;\r\n  }\r\n  SORT_IMPL<T>(buffer, byteOffset, length, comparator);\r\n  return array;\r\n}\r\n\r\n@inline\r\nexport function SUBARRAY<TArray extends TypedArray<T>, T>(\r\n  array: TArray,\r\n  begin: i32,\r\n  end: i32\r\n): TArray {\r\n  var length = <i32>array.length;\r\n  if (begin < 0) begin = max(length + begin, 0);\r\n  else begin = min(begin, length);\r\n  if (end < 0) end = max(length + end, begin);\r\n  else end = max(min(end, length), begin);\r\n  var slice = memory.allocate(offsetof<TArray>());\r\n  store<usize>(slice, array.buffer, offsetof<TArray>(\"buffer\"));\r\n  store<i32>(slice, <i32>array.byteOffset + (begin << alignof<T>()), offsetof<TArray>(\"byteOffset\"));\r\n  store<i32>(slice, (end - begin) << alignof<T>(), offsetof<TArray>(\"byteLength\"));\r\n  return changetype<TArray>(slice);\r\n}\r\n\r\n@inline\r\nexport function REDUCE<TArray extends TypedArray<T>, T, TRet>(\r\n  array: TArray,\r\n  callbackfn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\r\n  initialValue: TRet\r\n): TRet {\r\n  var length = array.length;\r\n  var buffer = array.buffer;\r\n  var byteOffset = array.byteOffset;\r\n  for (let i = 0; i < length; i++) {\r\n    initialValue = callbackfn(\r\n      initialValue,\r\n      LOAD<T>(buffer, i, byteOffset),\r\n      i,\r\n      array,\r\n    );\r\n  }\r\n  return initialValue;\r\n}\r\n\r\n@inline\r\nexport function REDUCE_RIGHT<TArray extends TypedArray<T>, T, TRet>(\r\n  array: TArray,\r\n  callbackfn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\r\n  initialValue: TRet\r\n): TRet {\r\n  var buffer = array.buffer;\r\n  var byteOffset = array.byteOffset;\r\n  for (let i = array.length - 1; i >= 0; i--) {\r\n    initialValue = callbackfn(\r\n      initialValue,\r\n      LOAD<T>(buffer, i, byteOffset),\r\n      i,\r\n      array,\r\n    );\r\n  }\r\n  return initialValue;\r\n}\r\n\r\n@inline\r\nexport function MAP<TArray extends TypedArray<T>, T>(\r\n  array: TArray,\r\n  callbackfn: (value: T, index: i32, self: TArray) => T,\r\n): TArray {\r\n  var length = array.length;\r\n  var buffer = array.buffer;\r\n  var byteOffset = array.byteOffset;\r\n  var result = instantiate<TArray>(length);\r\n  var resultBuffer = result.buffer;\r\n  for (let i = 0; i < length; i++) {\r\n    STORE<T, native<T>>(resultBuffer, i, <native<T>>callbackfn(LOAD<T>(buffer, i, byteOffset), i, array));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n@inline\r\nexport function FIND_INDEX<TArray extends TypedArray<T>, T>(\r\n  array: TArray,\r\n  callbackfn: (value: T, index: i32, array: TArray) => bool,\r\n): i32 {\r\n  var length = array.length;\r\n  var buffer = array.buffer;\r\n  var byteOffset = array.byteOffset;\r\n  for (let i = 0; i < length; i++) {\r\n    if (callbackfn(LOAD<T>(buffer, i, byteOffset), i, array)) {\r\n      return i;\r\n    }\r\n  }\r\n  return -1;\r\n}\r\n\r\n@inline\r\nexport function SOME<TArray extends TypedArray<T>, T>(\r\n  array: TArray,\r\n  callbackfn: (value: T, index: i32, array: TArray) => bool,\r\n): bool {\r\n  var length = array.length;\r\n  var buffer = array.buffer;\r\n  var byteOffset = array.byteOffset;\r\n  for (let i = 0; i < length; i++) {\r\n    if (callbackfn(LOAD<T>(buffer, i, byteOffset), i, array)) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n@inline\r\nexport function EVERY<TArray extends TypedArray<T>, T>(\r\n  array: TArray,\r\n  callbackfn: (value: T, index: i32, array: TArray) => bool,\r\n): bool {\r\n  var length = array.length;\r\n  var buffer = array.buffer;\r\n  var byteOffset = array.byteOffset;\r\n  for (let i = 0; i < length; i++) {\r\n    if (callbackfn(LOAD<T>(buffer, i, byteOffset), i, array)) {\r\n      continue;\r\n    }\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\n@inline\r\nexport function FOREACH<TArray extends TypedArray<T>, T>(\r\n  array: TArray,\r\n  callbackfn: (value: T, index: i32, array: TArray) => void,\r\n): void {\r\n  var length = array.length;\r\n  var buffer = array.buffer;\r\n  var byteOffset = array.byteOffset;\r\n  for (let i = 0; i < length; i++) {\r\n    callbackfn(LOAD<T>(buffer, i, byteOffset), i, array);\r\n  }\r\n}\r\n\r\n@inline\r\nexport function REVERSE<TArray extends TypedArray<T>, T>(array: TArray): TArray {\r\n  var buffer = array.buffer;\r\n  var byteOffset = array.byteOffset;\r\n\r\n  for (let front = 0, back = array.length - 1; front < back; ++front, --back) {\r\n    let temp = LOAD<T>(buffer, front, byteOffset);\r\n    STORE<T>(buffer, front, LOAD<T>(buffer, back, byteOffset), byteOffset);\r\n    STORE<T>(buffer, back, temp, byteOffset);\r\n  }\r\n  return array;\r\n}\r\n","import { memcmp, memmove, memset } from \"./internal/memory\";\r\n\r\n@builtin export declare const HEAP_BASE: usize; // tslint:disable-line\r\n\r\n/* tslint:disable */\r\n\r\nexport namespace memory {\r\n\r\n  @builtin export declare function size(): i32;\r\n\r\n  @builtin export declare function grow(pages: i32): i32;\r\n\r\n  @builtin @inline\r\n  export function fill(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\r\n    memset(dest, c, n); // fallback if \"bulk-memory\" isn't enabled\r\n  }\r\n\r\n  @builtin @inline\r\n  export function copy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\r\n    memmove(dest, src, n); // fallback if \"bulk-memory\" isn't enabled\r\n  }\r\n\r\n  @inline export function compare(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\r\n    return memcmp(vl, vr, n);\r\n  }\r\n\r\n  // Passive segments\r\n\r\n  // export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\r\n  //   __memory_init(segmentIndex, srcOffset, dstOffset);\r\n  // }\r\n\r\n  // export function drop(segmentIndex: u32): void {\r\n  //   __memory_drop(segmentIndex);\r\n  // }\r\n\r\n  // Allocator\r\n\r\n  @inline export function allocate(size: usize): usize {\r\n    if (isDefined(__memory_allocate)) return __memory_allocate(size);\r\n    WARNING(\"Calling 'memory.allocate' requires a memory manager to be present.\");\r\n    return <usize>unreachable();\r\n  }\r\n\r\n  @inline export function free(ptr: usize): void {\r\n    if (isDefined(__memory_free)) { __memory_free(ptr); return; }\r\n    WARNING(\"Calling 'memory.free' requires a memory manager to be present.\");\r\n    unreachable();\r\n  }\r\n\r\n  @inline export function reset(): void {\r\n    if (isDefined(__memory_reset)) { __memory_reset(); return; }\r\n    unreachable();\r\n  }\r\n}\r\n","// this function will go away once `memory.copy` becomes an intrinsic\r\nexport function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\r\n  var w: u32, x: u32;\r\n\r\n  // copy 1 byte each until src is aligned to 4 bytes\r\n  while (n && (src & 3)) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    n--;\r\n  }\r\n\r\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\r\n  if ((dest & 3) == 0) {\r\n    while (n >= 16) {\r\n      store<u32>(dest     , load<u32>(src     ));\r\n      store<u32>(dest +  4, load<u32>(src +  4));\r\n      store<u32>(dest +  8, load<u32>(src +  8));\r\n      store<u32>(dest + 12, load<u32>(src + 12));\r\n      src += 16; dest += 16; n -= 16;\r\n    }\r\n    if (n & 8) {\r\n      store<u32>(dest    , load<u32>(src    ));\r\n      store<u32>(dest + 4, load<u32>(src + 4));\r\n      dest += 8; src += 8;\r\n    }\r\n    if (n & 4) {\r\n      store<u32>(dest, load<u32>(src));\r\n      dest += 4; src += 4;\r\n    }\r\n    if (n & 2) { // drop to 2 bytes each\r\n      store<u16>(dest, load<u16>(src));\r\n      dest += 2; src += 2;\r\n    }\r\n    if (n & 1) { // drop to 1 byte\r\n      store<u8>(dest++, load<u8>(src++));\r\n    }\r\n    return;\r\n  }\r\n\r\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\r\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\r\n  if (n >= 32) {\r\n    switch (dest & 3) {\r\n      // known to be != 0\r\n      case 1: {\r\n        w = load<u32>(src);\r\n        store<u8>(dest++, load<u8>(src++));\r\n        store<u8>(dest++, load<u8>(src++));\r\n        store<u8>(dest++, load<u8>(src++));\r\n        n -= 3;\r\n        while (n >= 17) {\r\n          x = load<u32>(src + 1);\r\n          store<u32>(dest, w >> 24 | x << 8);\r\n          w = load<u32>(src + 5);\r\n          store<u32>(dest + 4, x >> 24 | w << 8);\r\n          x = load<u32>(src + 9);\r\n          store<u32>(dest + 8, w >> 24 | x << 8);\r\n          w = load<u32>(src + 13);\r\n          store<u32>(dest + 12, x >> 24 | w << 8);\r\n          src += 16; dest += 16; n -= 16;\r\n        }\r\n        break;\r\n      }\r\n      case 2: {\r\n        w = load<u32>(src);\r\n        store<u8>(dest++, load<u8>(src++));\r\n        store<u8>(dest++, load<u8>(src++));\r\n        n -= 2;\r\n        while (n >= 18) {\r\n          x = load<u32>(src + 2);\r\n          store<u32>(dest, w >> 16 | x << 16);\r\n          w = load<u32>(src + 6);\r\n          store<u32>(dest + 4, x >> 16 | w << 16);\r\n          x = load<u32>(src + 10);\r\n          store<u32>(dest + 8, w >> 16 | x << 16);\r\n          w = load<u32>(src + 14);\r\n          store<u32>(dest + 12, x >> 16 | w << 16);\r\n          src += 16; dest += 16; n -= 16;\r\n        }\r\n        break;\r\n      }\r\n      case 3: {\r\n        w = load<u32>(src);\r\n        store<u8>(dest++, load<u8>(src++));\r\n        n -= 1;\r\n        while (n >= 19) {\r\n          x = load<u32>(src + 3);\r\n          store<u32>(dest, w >> 8 | x << 24);\r\n          w = load<u32>(src + 7);\r\n          store<u32>(dest + 4, x >> 8 | w << 24);\r\n          x = load<u32>(src + 11);\r\n          store<u32>(dest + 8, w >> 8 | x << 24);\r\n          w = load<u32>(src + 15);\r\n          store<u32>(dest + 12, x >> 8 | w << 24);\r\n          src += 16; dest += 16; n -= 16;\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  // copy remaining bytes one by one\r\n  if (n & 16) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 8) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 4) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 2) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 1) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n}\r\n\r\n// this function will go away once `memory.copy` becomes an intrinsic\r\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\r\n  if (dest === src) return;\r\n  if (src + n <= dest || dest + n <= src) {\r\n    memcpy(dest, src, n);\r\n    return;\r\n  }\r\n  if (dest < src) {\r\n    if ((src & 7) == (dest & 7)) {\r\n      while (dest & 7) {\r\n        if (!n) return;\r\n        --n;\r\n        store<u8>(dest++, load<u8>(src++));\r\n      }\r\n      while (n >= 8) {\r\n        store<u64>(dest, load<u64>(src));\r\n        n    -= 8;\r\n        dest += 8;\r\n        src  += 8;\r\n      }\r\n    }\r\n    while (n) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n      --n;\r\n    }\r\n  } else {\r\n    if ((src & 7) == (dest & 7)) {\r\n      while ((dest + n) & 7) {\r\n        if (!n) return;\r\n        store<u8>(dest + --n, load<u8>(src + n));\r\n      }\r\n      while (n >= 8) {\r\n        n -= 8;\r\n        store<u64>(dest + n, load<u64>(src + n));\r\n      }\r\n    }\r\n    while (n) {\r\n      store<u8>(dest + --n, load<u8>(src + n));\r\n    }\r\n  }\r\n}\r\n\r\n// this function will go away once `memory.fill` becomes an intrinsic\r\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\r\n\r\n  // fill head and tail with minimal branching\r\n  if (!n) return;\r\n  store<u8>(dest, c);\r\n  store<u8>(dest + n - 1, c);\r\n  if (n <= 2) return;\r\n\r\n  store<u8>(dest + 1, c);\r\n  store<u8>(dest + 2, c);\r\n  store<u8>(dest + n - 2, c);\r\n  store<u8>(dest + n - 3, c);\r\n  if (n <= 6) return;\r\n  store<u8>(dest + 3, c);\r\n  store<u8>(dest + n - 4, c);\r\n  if (n <= 8) return;\r\n\r\n  // advance pointer to align it at 4-byte boundary\r\n  var k: usize = -dest & 3;\r\n  dest += k;\r\n  n -= k;\r\n  n &= -4;\r\n\r\n  var c32: u32 = <u32>-1 / 255 * c;\r\n\r\n  // fill head/tail up to 28 bytes each in preparation\r\n  store<u32>(dest, c32);\r\n  store<u32>(dest + n - 4, c32);\r\n  if (n <= 8) return;\r\n  store<u32>(dest + 4, c32);\r\n  store<u32>(dest + 8, c32);\r\n  store<u32>(dest + n - 12, c32);\r\n  store<u32>(dest + n - 8, c32);\r\n  if (n <= 24) return;\r\n  store<u32>(dest + 12, c32);\r\n  store<u32>(dest + 16, c32);\r\n  store<u32>(dest + 20, c32);\r\n  store<u32>(dest + 24, c32);\r\n  store<u32>(dest + n - 28, c32);\r\n  store<u32>(dest + n - 24, c32);\r\n  store<u32>(dest + n - 20, c32);\r\n  store<u32>(dest + n - 16, c32);\r\n\r\n  // align to a multiple of 8\r\n  k = 24 + (dest & 4);\r\n  dest += k;\r\n  n -= k;\r\n\r\n  // copy 32 bytes each\r\n  var c64: u64 = <u64>c32 | (<u64>c32 << 32);\r\n  while (n >= 32) {\r\n    store<u64>(dest, c64);\r\n    store<u64>(dest + 8, c64);\r\n    store<u64>(dest + 16, c64);\r\n    store<u64>(dest + 24, c64);\r\n    n -= 32;\r\n    dest += 32;\r\n  }\r\n}\r\n\r\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\r\n  if (vl == vr) return 0;\r\n  while (n != 0 && load<u8>(vl) == load<u8>(vr)) {\r\n    n--; vl++; vr++;\r\n  }\r\n  return n ? <i32>load<u8>(vl) - <i32>load<u8>(vr) : 0;\r\n}\r\n","import 'allocator/arena'\n// @ts-ignore\nexport { memory }\n\ndeclare namespace console {\n  // @ts-ignore 정말 없애버리고 싶지만 디버그 때문에 만듬\n  @external('console', 'log')\n  export function log (s: i32): void\n  // @ts-ignore\n  @external('console', 'time')\n  export function time (): void\n\n}\n\nlet chunk: Uint32Array = new Uint32Array(65536)\nlet vertices: Uint32Array = new Uint32Array(65536 * 12)\nlet faces: Uint32Array = new Uint32Array(65536 * 6)\nlet verticeIndex: i32\nlet faceIndex: i32\n\nfunction getBlock (x: u32, y: u32, z: u32): u32 {\n  return chunk[(x << 12) + (z << 8) + y]\n}\n\nexport function mergeFace (faceData: Uint32Array, width: u32, height: u32, rotType: u8, depth: u32): void {\n  let startX: u32 = 0\n  let startY: u32 = 0\n  let searchX: u32 = 0\n  let searchY: u32 = 0\n  let id: u32 = 0\n  let exist = false\n  let xRot = rotType >> 2 & 1\n  let yRot = rotType >> 1 & 1\n  let zRot = rotType >> 0 & 1\n  while (true) {\n    exist = false\n    for (let i: i32 = startX + startY * width; i < faceData.length; i++) {\n      if (faceData[i] !== 0) {\n        id = faceData[i]\n        startY = ((i / width) as u32) | 0 // Force Integer\n        startX = (i - startY * width) as u32\n        exist = true\n        break\n      }\n    }\n    if (!exist) break\n    let nowHeight = startY * width\n    for (searchX = startX; searchX < width; searchX++) {\n      if (faceData[nowHeight + searchX] !== id) break\n    }\n    searchX--\n    let found = false\n    for (searchY = startY; searchY < height; searchY++) {\n      for (let x: u32 = startX; x <= searchX; x++) {\n        if (faceData[searchY * width + x] !== id) {\n          found = true\n          break\n        }\n      }\n      if (found) break\n    }\n    searchY--\n    if (xRot === 1) {\n      vertices[verticeIndex] = startX\n      vertices[verticeIndex + 3] = searchX\n      vertices[verticeIndex + 6] = searchX\n      vertices[verticeIndex + 9] = startX\n    } else {\n      vertices[verticeIndex] = depth\n      vertices[verticeIndex + 3] = depth\n      vertices[verticeIndex + 6] = depth\n      vertices[verticeIndex + 9] = depth\n    }\n    if (yRot === 1) {\n      if (xRot === 0) {\n        vertices[verticeIndex + 1] = startX\n        vertices[verticeIndex + 4] = searchX\n        vertices[verticeIndex + 7] = searchX\n        vertices[verticeIndex + 10] = startX\n      } else {\n        vertices[verticeIndex + 1] = startY\n        vertices[verticeIndex + 4] = startY\n        vertices[verticeIndex + 7] = searchY\n        vertices[verticeIndex + 10] = searchY\n      }\n    } else {\n      vertices[verticeIndex + 1] = depth\n      vertices[verticeIndex + 4] = depth\n      vertices[verticeIndex + 7] = depth\n      vertices[verticeIndex + 10] = depth\n    }\n    if (zRot === 1) {\n      vertices[verticeIndex + 2] = startY\n      vertices[verticeIndex + 5] = startY\n      vertices[verticeIndex + 8] = searchY\n      vertices[verticeIndex + 11] = searchY\n    } else {\n      vertices[verticeIndex + 2] = depth\n      vertices[verticeIndex + 5] = depth\n      vertices[verticeIndex + 8] = depth\n      vertices[verticeIndex + 11] = depth\n    }\n\n    let faceVerticeIndex = verticeIndex / 3\n    faces[faceIndex] = faceVerticeIndex\n    faces[faceIndex + 1] = faceVerticeIndex + 1\n    faces[faceIndex + 2] = faceVerticeIndex + 2\n    faces[faceIndex + 3] = faceVerticeIndex\n    faces[faceIndex + 4] = faceVerticeIndex + 2\n    faces[faceIndex + 5] = faceVerticeIndex + 3\n    for (let x: u32 = startX; x <= searchX; x++) {\n      for (let y: u32 = startY; y <= searchY; y++) {\n        faceData[y * width + x] = 0\n      }\n    }\n    verticeIndex += 12\n    faceIndex += 6\n  }\n}\n\nexport function optimize (data: Uint32Array): void {\n  chunk = data\n  vertices.fill(0)\n  faces.fill(0)\n  verticeIndex = 0\n  faceIndex = 0\n  for (let x: u32 = 0; x <= 15; x++) {\n    let frontFace = new Uint32Array(4096)\n    let backFace = new Uint32Array(4096)\n    for (let y: u32 = 0; y <= 255; y++) {\n      for (let z: u32 = 0; z <= 15; z++) {\n        let block = getBlock(x, y, z)\n        let frontBlock = x === 15 ? 0 : getBlock(x + 1, y, z)\n        if (frontBlock === 0) {\n          frontFace[(z << 8) + y] = block\n        }\n        let backBlock = x === 0 ? 0 : getBlock(x - 1, y, z)\n        if (backBlock === 0) {\n          backFace[(z << 8) + y] = block\n        }\n      }\n    }\n    mergeFace(frontFace, 256, 16, 0b011, x)\n    mergeFace(backFace, 256, 16, 0b011, x)\n  }\n  for (let y: u32 = 0; y <= 255; y++) {\n    let frontFace = new Uint32Array(256)\n    let backFace = new Uint32Array(256)\n    for (let z: u32 = 0; z <= 15; z++) {\n      for (let x: u32 = 0; x <= 15; x++) {\n        let block = getBlock(x, y, z)\n        let frontBlock = y === 255 ? 0 : getBlock(x, y + 1, z)\n        if (frontBlock === 0) {\n          frontFace[(x << 4) + z] = block\n        }\n        let backBlock = y === 0 ? 0 : getBlock(x, y - 1, z)\n        if (backBlock === 0) {\n          backFace[(x << 4) + z] = block\n        }\n      }\n    }\n    mergeFace(frontFace, 16, 16, 0b101, y)\n    mergeFace(backFace, 16, 16, 0b101, y)\n  }\n  for (let z: u32 = 0; z <= 15; z++) {\n    let frontFace = new Uint32Array(4096)\n    let backFace = new Uint32Array(4096)\n    for (let y: u32 = 0; y <= 255; y++) {\n      for (let x: u32 = 0; x <= 15; x++) {\n        let block = getBlock(x, y, z)\n        let frontBlock = z === 15 ? 0 : getBlock(x, y, z + 1)\n        if (frontBlock === 0) {\n          frontFace[(x << 8) + y] = block\n        }\n        let backBlock = z === 0 ? 0 : getBlock(x, y, z - 1)\n        if (backBlock === 0) {\n          backFace[(x << 8) + y] = block\n        }\n      }\n    }\n    mergeFace(frontFace, 16, 256, 0b110, z)\n    mergeFace(backFace, 16, 256, 0b110, z)\n  }\n  memory.free(changetype<usize>(chunk))\n  memory.free(changetype<usize>(data))\n}\n\nexport function getVertices (): Uint32Array {\n  return vertices.subarray(0, verticeIndex)\n}\n\nexport function getFaces (): Uint32Array {\n  return faces.subarray(0, faceIndex)\n}\n","import {\r\n  TypedArray,\r\n  FILL,\r\n  SORT,\r\n  SUBARRAY,\r\n  REDUCE,\r\n  REDUCE_RIGHT,\r\n  MAP,\r\n  FIND_INDEX,\r\n  SOME,\r\n  EVERY,\r\n  FOREACH,\r\n  REVERSE,\r\n} from \"./internal/typedarray\";\r\n\r\nimport {\r\n  COMPARATOR\r\n} from \"./internal/sort\";\r\n\r\nfunction clampToByte(value: i32): i32 {\r\n  return ~(value >> 31) & (((255 - value) >> 31) | value); // & 255\r\n}\r\n\r\nexport class Int8Array extends TypedArray<i8> {\r\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<i8>();\r\n\r\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\r\n    return FILL<Int8Array, i8>(this, value, start, end);\r\n  }\r\n\r\n  sort(comparator: (a: i8, b: i8) => i32 = COMPARATOR<i8>()): Int8Array {\r\n    return SORT<Int8Array, i8>(this, comparator);\r\n  }\r\n\r\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Int8Array {\r\n    return SUBARRAY<Int8Array, i8>(this, begin, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    callbackfn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Int8Array, i8, T>(this, callbackfn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    callbackfn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Int8Array, i8, T>(this, callbackfn, initialValue);\r\n  }\r\n\r\n  map(callbackfn: (value: i8, index: i32, self: Int8Array) => i8): Int8Array {\r\n    return MAP<Int8Array, i8>(this, callbackfn);\r\n  }\r\n\r\n  findIndex(callbackfn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\r\n    return FIND_INDEX<Int8Array, i8>(this, callbackfn);\r\n  }\r\n\r\n  some(callbackfn: (value: i8, index: i32, self: Int8Array) => bool): bool {\r\n    return SOME<Int8Array, i8>(this, callbackfn);\r\n  }\r\n\r\n  every(callbackfn: (value: i8, index: i32, self: Int8Array) => bool): bool {\r\n    return EVERY<Int8Array, i8>(this, callbackfn);\r\n  }\r\n\r\n  forEach(callbackfn: (value: i8, index: i32, self: Int8Array) => void): void {\r\n    FOREACH<Int8Array, i8>(this, callbackfn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, i8>(this);\r\n  }\r\n}\r\n\r\nexport class Uint8Array extends TypedArray<u8> {\r\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<u8>();\r\n\r\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\r\n    return FILL<Uint8Array, u8>(this, value, start, end);\r\n  }\r\n\r\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8Array {\r\n    return SORT<Uint8Array, u8>(this, comparator);\r\n  }\r\n\r\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint8Array {\r\n    return SUBARRAY<Uint8Array, u8>(this, begin, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    callbackfn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Uint8Array, u8, T>(this, callbackfn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    callbackfn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Uint8Array, u8, T>(this, callbackfn, initialValue);\r\n  }\r\n\r\n  map(callbackfn: (value: u8, index: i32, self: Uint8Array) => u8): Uint8Array {\r\n    return MAP<Uint8Array, u8>(this, callbackfn);\r\n  }\r\n\r\n  findIndex(callbackfn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\r\n    return FIND_INDEX<Uint8Array, u8>(this, callbackfn);\r\n  }\r\n\r\n  some(callbackfn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\r\n    return SOME<Uint8Array, u8>(this, callbackfn);\r\n  }\r\n\r\n  every(callbackfn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\r\n    return EVERY<Uint8Array, u8>(this, callbackfn);\r\n  }\r\n\r\n  forEach(callbackfn: (value: u8, index: i32, self: Uint8Array) => void): void {\r\n    FOREACH<Uint8Array, u8>(this, callbackfn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, u8>(this);\r\n  }\r\n}\r\n\r\nexport class Uint8ClampedArray extends Uint8Array {\r\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<u8>();\r\n\r\n  @inline @operator(\"[]=\")\r\n  protected __set(index: i32, value: i32): void {\r\n    super.__set(index, clampToByte(value));\r\n  }\r\n\r\n  @inline @operator(\"{}=\")\r\n  protected __unchecked_set(index: i32, value: i32): void {\r\n    super.__unchecked_set(index, clampToByte(value));\r\n  }\r\n\r\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\r\n    return changetype<Uint8ClampedArray>(super.fill(value, start, end)); // safe because '.fill' reuses 'this'\r\n  }\r\n\r\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8ClampedArray {\r\n    return changetype<Uint8ClampedArray>(super.sort(comparator)); // safe because '.sort' reuses 'this'\r\n  }\r\n\r\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint8ClampedArray {\r\n    return SUBARRAY<Uint8ClampedArray, u8>(this, begin, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    callbackfn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Uint8ClampedArray, u8, T>(this, callbackfn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    callbackfn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Uint8ClampedArray, u8, T>(this, callbackfn, initialValue);\r\n  }\r\n\r\n  map(callbackfn: (value: u8, index: i32, self: Uint8ClampedArray) => u8): Uint8ClampedArray {\r\n    return MAP<Uint8ClampedArray, u8>(this, callbackfn);\r\n  }\r\n\r\n  findIndex(callbackfn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\r\n    return FIND_INDEX<Uint8ClampedArray, u8>(this, callbackfn);\r\n  }\r\n\r\n  some(callbackfn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\r\n    return SOME<Uint8ClampedArray, u8>(this, callbackfn);\r\n  }\r\n\r\n  every(callbackfn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\r\n    return EVERY<Uint8ClampedArray, u8>(this, callbackfn);\r\n  }\r\n\r\n  forEach(callbackfn: (value: u8, index: i32, self: Uint8ClampedArray) => void): void {\r\n    FOREACH<Uint8ClampedArray, u8>(this, callbackfn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, u8>(this);\r\n  }\r\n}\r\n\r\nexport class Int16Array extends TypedArray<i16> {\r\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<i16>();\r\n\r\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\r\n    return FILL<Int16Array, i16>(this, value, start, end);\r\n  }\r\n\r\n  sort(comparator: (a: i16, b: i16) => i32 = COMPARATOR<i16>()): Int16Array {\r\n    return SORT<Int16Array, i16>(this, comparator);\r\n  }\r\n\r\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Int16Array {\r\n    return SUBARRAY<Int16Array, i16>(this, begin, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    callbackfn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Int16Array, i16, T>(this, callbackfn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    callbackfn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Int16Array, i16, T>(this, callbackfn, initialValue);\r\n  }\r\n\r\n  map(callbackfn: (value: i16, index: i32, self: Int16Array) => i16): Int16Array {\r\n    return MAP<Int16Array, i16>(this, callbackfn);\r\n  }\r\n\r\n  findIndex(callbackfn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\r\n    return FIND_INDEX<Int16Array, i16>(this, callbackfn);\r\n  }\r\n\r\n  some(callbackfn: (value: i16, index: i32, self: Int16Array) => bool): bool {\r\n    return SOME<Int16Array, i16>(this, callbackfn);\r\n  }\r\n\r\n  every(callbackfn: (value: i16, index: i32, self: Int16Array) => bool): bool {\r\n    return EVERY<Int16Array, i16>(this, callbackfn);\r\n  }\r\n\r\n  forEach(callbackfn: (value: i16, index: i32, self: Int16Array) => void): void {\r\n    FOREACH<Int16Array, i16>(this, callbackfn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, i16>(this);\r\n  }\r\n}\r\n\r\nexport class Uint16Array extends TypedArray<u16> {\r\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<u16>();\r\n\r\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\r\n    return FILL<Uint16Array, u16>(this, value, start, end);\r\n  }\r\n\r\n  sort(comparator: (a: u16, b: u16) => i32 = COMPARATOR<u16>()): Uint16Array {\r\n    return SORT<Uint16Array, u16>(this, comparator);\r\n  }\r\n\r\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint16Array {\r\n    return SUBARRAY<Uint16Array, u16>(this, begin, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    callbackfn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Uint16Array, u16, T>(this, callbackfn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    callbackfn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Uint16Array, u16, T>(this, callbackfn, initialValue);\r\n  }\r\n\r\n  map(callbackfn: (value: u16, index: i32, self: Uint16Array) => u16): Uint16Array {\r\n    return MAP<Uint16Array, u16>(this, callbackfn);\r\n  }\r\n\r\n  findIndex(callbackfn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\r\n    return FIND_INDEX<Uint16Array, u16>(this, callbackfn);\r\n  }\r\n\r\n  some(callbackfn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\r\n    return SOME<Uint16Array, u16>(this, callbackfn);\r\n  }\r\n\r\n  every(callbackfn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\r\n    return EVERY<Uint16Array, u16>(this, callbackfn);\r\n  }\r\n\r\n  forEach(callbackfn: (value: u16, index: i32, self: Uint16Array) => void): void {\r\n    FOREACH<Uint16Array, u16>(this, callbackfn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, u16>(this);\r\n  }\r\n}\r\n\r\nexport class Int32Array extends TypedArray<i32> {\r\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<i32>();\r\n\r\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\r\n    return FILL<Int32Array, i32>(this, value, start, end);\r\n  }\r\n\r\n  sort(comparator: (a: i32, b: i32) => i32 = COMPARATOR<i32>()): Int32Array {\r\n    return SORT<Int32Array, i32>(this, comparator);\r\n  }\r\n\r\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Int32Array {\r\n    return SUBARRAY<Int32Array, i32>(this, begin, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    callbackfn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Int32Array, i32, T>(this, callbackfn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    callbackfn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Int32Array, i32, T>(this, callbackfn, initialValue);\r\n  }\r\n\r\n  map(callbackfn: (value: i32, index: i32, self: Int32Array) => i32): Int32Array {\r\n    return MAP<Int32Array, i32>(this, callbackfn);\r\n  }\r\n\r\n  findIndex(callbackfn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\r\n    return FIND_INDEX<Int32Array, i32>(this, callbackfn);\r\n  }\r\n\r\n  some(callbackfn: (value: i32, index: i32, self: Int32Array) => bool): bool {\r\n    return SOME<Int32Array, i32>(this, callbackfn);\r\n  }\r\n\r\n  every(callbackfn: (value: i32, index: i32, self: Int32Array) => bool): bool {\r\n    return EVERY<Int32Array, i32>(this, callbackfn);\r\n  }\r\n\r\n  forEach(callbackfn: (value: i32, index: i32, self: Int32Array) => void): void {\r\n    FOREACH<Int32Array, i32>(this, callbackfn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, i32>(this);\r\n  }\r\n}\r\n\r\nexport class Uint32Array extends TypedArray<u32> {\r\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<u32>();\r\n\r\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\r\n    return FILL<Uint32Array, u32>(this, value, start, end);\r\n  }\r\n\r\n  sort(comparator: (a: u32, b: u32) => i32 = COMPARATOR<u32>()): Uint32Array {\r\n    return SORT<Uint32Array, u32>(this, comparator);\r\n  }\r\n\r\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint32Array {\r\n    return SUBARRAY<Uint32Array, u32>(this, begin, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    callbackfn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Uint32Array, u32, T>(this, callbackfn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    callbackfn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Uint32Array, u32, T>(this, callbackfn, initialValue);\r\n  }\r\n\r\n  map(callbackfn: (value: u32, index: i32, self: Uint32Array) => u32): Uint32Array {\r\n    return MAP<Uint32Array, u32>(this, callbackfn);\r\n  }\r\n\r\n  findIndex(callbackfn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\r\n    return FIND_INDEX<Uint32Array, u32>(this, callbackfn);\r\n  }\r\n\r\n  some(callbackfn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\r\n    return SOME<Uint32Array, u32>(this, callbackfn);\r\n  }\r\n\r\n  every(callbackfn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\r\n    return EVERY<Uint32Array, u32>(this, callbackfn);\r\n  }\r\n\r\n  forEach(callbackfn: (value: u32, index: i32, self: Uint32Array) => void): void {\r\n    FOREACH<Uint32Array, u32>(this, callbackfn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, u32>(this);\r\n  }\r\n}\r\n\r\nexport class Int64Array extends TypedArray<i64> {\r\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<i64>();\r\n\r\n  fill(value: i64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\r\n    return FILL<Int64Array, i64>(this, value, start, end);\r\n  }\r\n\r\n  sort(comparator: (a: i64, b: i64) => i32 = COMPARATOR<i64>()): Int64Array {\r\n    return SORT<Int64Array, i64>(this, comparator);\r\n  }\r\n\r\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Int64Array {\r\n    return SUBARRAY<Int64Array, i64>(this, begin, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    callbackfn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Int64Array, i64, T>(this, callbackfn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    callbackfn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Int64Array, i64, T>(this, callbackfn, initialValue);\r\n  }\r\n\r\n  map(callbackfn: (value: i64, index: i32, self: Int64Array) => i64): Int64Array {\r\n    return MAP<Int64Array, i64>(this, callbackfn);\r\n  }\r\n\r\n  findIndex(callbackfn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\r\n    return FIND_INDEX<Int64Array, i64>(this, callbackfn);\r\n  }\r\n\r\n  some(callbackfn: (value: i64, index: i32, self: Int64Array) => bool): bool {\r\n    return SOME<Int64Array, i64>(this, callbackfn);\r\n  }\r\n\r\n  every(callbackfn: (value: i64, index: i32, self: Int64Array) => bool): bool {\r\n    return EVERY<Int64Array, i64>(this, callbackfn);\r\n  }\r\n\r\n  forEach(callbackfn: (value: i64, index: i32, self: Int64Array) => void): void {\r\n    FOREACH<Int64Array, i64>(this, callbackfn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, i64>(this);\r\n  }\r\n}\r\n\r\nexport class Uint64Array extends TypedArray<u64> {\r\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<u64>();\r\n\r\n  fill(value: u64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\r\n    return FILL<Uint64Array, u64>(this, value, start, end);\r\n  }\r\n\r\n  sort(comparator: (a: u64, b: u64) => i32 = COMPARATOR<u64>()): Uint64Array {\r\n    return SORT<Uint64Array, u64>(this, comparator);\r\n  }\r\n\r\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint64Array {\r\n    return SUBARRAY<Uint64Array, u64>(this, begin, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    callbackfn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Uint64Array, u64, T>(this, callbackfn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    callbackfn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Uint64Array, u64, T>(this, callbackfn, initialValue);\r\n  }\r\n\r\n  map(callbackfn: (value: u64, index: i32, self: Uint64Array) => u64): Uint64Array {\r\n    return MAP<Uint64Array, u64>(this, callbackfn);\r\n  }\r\n\r\n  findIndex(callbackfn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\r\n    return FIND_INDEX<Uint64Array, u64>(this, callbackfn);\r\n  }\r\n\r\n  some(callbackfn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\r\n    return SOME<Uint64Array, u64>(this, callbackfn);\r\n  }\r\n\r\n  every(callbackfn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\r\n    return EVERY<Uint64Array, u64>(this, callbackfn);\r\n  }\r\n\r\n  forEach(callbackfn: (value: u64, index: i32, self: Uint64Array) => void): void {\r\n    FOREACH<Uint64Array, u64>(this, callbackfn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, u64>(this);\r\n  }\r\n}\r\n\r\nexport class Float32Array extends TypedArray<f32> {\r\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<f32>();\r\n\r\n  fill(value: f32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\r\n    return FILL<Float32Array, f32>(this, value, start, end);\r\n  }\r\n\r\n  sort(comparator: (a: f32, b: f32) => i32 = COMPARATOR<f32>()): Float32Array {\r\n    return SORT<Float32Array, f32>(this, comparator);\r\n  }\r\n\r\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Float32Array {\r\n    return SUBARRAY<Float32Array, f32>(this, begin, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    callbackfn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Float32Array, f32, T>(this, callbackfn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    callbackfn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Float32Array, f32, T>(this, callbackfn, initialValue);\r\n  }\r\n\r\n  map(callbackfn: (value: f32, index: i32, self: Float32Array) => f32): Float32Array {\r\n    return MAP<Float32Array, f32>(this, callbackfn);\r\n  }\r\n\r\n  findIndex(callbackfn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\r\n    return FIND_INDEX<Float32Array, f32>(this, callbackfn);\r\n  }\r\n\r\n  some(callbackfn: (value: f32, index: i32, self: Float32Array) => bool): bool {\r\n    return SOME<Float32Array, f32>(this, callbackfn);\r\n  }\r\n\r\n  every(callbackfn: (value: f32, index: i32, self: Float32Array) => bool): bool {\r\n    return EVERY<Float32Array, f32>(this, callbackfn);\r\n  }\r\n\r\n  forEach(callbackfn: (value: f32, index: i32, self: Float32Array) => void): void {\r\n    FOREACH<Float32Array, f32>(this, callbackfn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, f32>(this);\r\n  }\r\n}\r\n\r\nexport class Float64Array extends TypedArray<f64> {\r\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<f64>();\r\n\r\n  fill(value: f64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\r\n    return FILL<Float64Array, f64>(this, value, start, end);\r\n  }\r\n\r\n  sort(comparator: (a: f64, b: f64) => i32 = COMPARATOR<f64>()): Float64Array {\r\n    return SORT<Float64Array, f64>(this, comparator);\r\n  }\r\n\r\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Float64Array {\r\n    return SUBARRAY<Float64Array, f64>(this, begin, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    callbackfn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Float64Array, f64, T>(this, callbackfn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    callbackfn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Float64Array, f64, T>(this, callbackfn, initialValue);\r\n  }\r\n\r\n  map(callbackfn: (value: f64, index: i32, self: Float64Array) => f64): Float64Array {\r\n    return MAP<Float64Array, f64>(this, callbackfn);\r\n  }\r\n\r\n  findIndex(callbackfn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\r\n    return FIND_INDEX<Float64Array, f64>(this, callbackfn);\r\n  }\r\n\r\n  some(callbackfn: (value: f64, index: i32, self: Float64Array) => bool): bool {\r\n    return SOME<Float64Array, f64>(this, callbackfn);\r\n  }\r\n\r\n  every(callbackfn: (value: f64, index: i32, self: Float64Array) => bool): bool {\r\n    return EVERY<Float64Array, f64>(this, callbackfn);\r\n  }\r\n\r\n  forEach(callbackfn: (value: f64, index: i32, self: Float64Array) => void): void {\r\n    FOREACH<Float64Array, f64>(this, callbackfn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, f64>(this);\r\n  }\r\n}\r\n","/* tslint:disable */\r\n\r\n@builtin @inline export const NaN: f64 = 0 / 0;\r\n@builtin @inline export const Infinity: f64 = 1 / 0;\r\n\r\n@builtin export declare function isInteger<T>(value?: T): bool;\r\n@builtin export declare function isFloat<T>(value?: T): bool;\r\n@builtin export declare function isSigned<T>(value?: T): bool;\r\n@builtin export declare function isReference<T>(value?: T): bool;\r\n@builtin export declare function isString<T>(value?: T): bool;\r\n@builtin export declare function isArray<T>(value?: T): bool;\r\n@builtin export declare function isArrayLike<T>(value?: T): bool;\r\n@builtin export declare function isFunction<T>(value?: T): bool;\r\n@builtin export declare function isNullable<T>(value?: T): bool;\r\n@builtin export declare function isDefined(expression: void): bool;\r\n@builtin export declare function isConstant(expression: void): bool;\r\n@builtin export declare function isManaged<T>(value?: T): bool;\r\n@inline export function isNaN<T>(value: T): bool { return value != value; }\r\n@inline export function isFinite<T>(value: T): bool { return value - value == 0; }\r\n\r\n@builtin export declare function clz<T>(value: T): T;\r\n@builtin export declare function ctz<T>(value: T): T;\r\n@builtin export declare function popcnt<T>(value: T): T;\r\n@builtin export declare function rotl<T>(value: T, shift: T): T;\r\n@builtin export declare function rotr<T>(value: T, shift: T): T;\r\n@builtin export declare function abs<T>(value: T): T;\r\n@builtin export declare function max<T>(left: T, right: T): T;\r\n@builtin export declare function min<T>(left: T, right: T): T;\r\n@builtin export declare function ceil<T>(value: T): T;\r\n@builtin export declare function floor<T>(value: T): T;\r\n@builtin export declare function copysign<T>(left: T, right: T): T;\r\n@builtin export declare function nearest<T>(value: T): T;\r\n@builtin export declare function reinterpret<T>(value: void): T;\r\n@builtin export declare function sqrt<T>(value: T): T;\r\n@builtin export declare function trunc<T>(value: T): T;\r\n@builtin export declare function load<T>(offset: usize, immOffset?: usize, immAlign?: usize): T;\r\n@builtin export declare function store<T>(offset: usize, value: void, immOffset?: usize, immAlign?: usize): void;\r\n@builtin export declare function sizeof<T>(): usize; // | u32 / u64\r\n@builtin export declare function alignof<T>(): usize; // | u32 / u64\r\n@builtin export declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64\r\n@builtin export declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\r\n@builtin export declare function unreachable(): void;\r\n@builtin export declare function changetype<T>(value: void): T;\r\n@builtin export declare function assert<T>(isTrueish: T, message?: string): T;\r\n@builtin export declare function unchecked<T>(expr: T): T;\r\n@builtin export declare function call_indirect<T>(target: void, ...args: void[]): T;\r\n@builtin export declare function instantiate<T>(...args: void[]): T;\r\n\r\nexport namespace atomic {\r\n  @builtin export declare function load<T>(offset: usize, immOffset?: usize): T;\r\n  @builtin export declare function store<T>(offset: usize, value: T, immOffset?: usize): void;\r\n  @builtin export declare function add<T>(ptr: usize, value: T, immOffset?: usize): T;\r\n  @builtin export declare function sub<T>(ptr: usize, value: T, immOffset?: usize): T;\r\n  @builtin export declare function and<T>(ptr: usize, value: T, immOffset?: usize): T;\r\n  @builtin export declare function or<T>(ptr: usize, value: T, immOffset?: usize): T;\r\n  @builtin export declare function xor<T>(ptr: usize, value: T, immOffset?: usize): T;\r\n  @builtin export declare function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;\r\n  @builtin export declare function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;\r\n  @builtin export declare function wait<T>(ptr: usize, expected: T, timeout: i64): AtomicWaitResult;\r\n  @builtin export declare function notify<T>(ptr: usize, count: i32): i32;\r\n}\r\n\r\n@lazy export const enum AtomicWaitResult {\r\n  OK = 0,\r\n  NOT_EQUAL = 1,\r\n  TIMED_OUT = 2\r\n}\r\n\r\n@builtin export declare function i8(value: void): i8;\r\nexport namespace i8 {\r\n  @lazy export const MIN_VALUE: i8 = -128;\r\n  @lazy export const MAX_VALUE: i8 =  127;\r\n}\r\n\r\n@builtin export declare function i16(value: void): i16;\r\nexport namespace i16 {\r\n  @lazy export const MIN_VALUE: i16 = -32768;\r\n  @lazy export const MAX_VALUE: i16 =  32767;\r\n}\r\n\r\n@builtin export declare function i32(value: void): i32;\r\nexport namespace i32 {\r\n  @lazy export const MIN_VALUE: i32 = -2147483648;\r\n  @lazy export const MAX_VALUE: i32 =  2147483647;\r\n  @builtin export declare function clz(value: i32): i32;\r\n  @builtin export declare function ctz(value: i32): i32;\r\n  @builtin export declare function popcnt(value: i32): i32;\r\n  @builtin export declare function rotl(value: i32, shift: i32): i32;\r\n  @builtin export declare function rotr(value: i32, shift: i32): i32;\r\n  @builtin export declare function reinterpret_f32(value: f32): i32;\r\n  @builtin export declare function load8_s(offset: usize, immOffset?: usize, immAlign?: usize): i32;\r\n  @builtin export declare function load8_u(offset: usize, immOffset?: usize, immAlign?: usize): i32;\r\n  @builtin export declare function load16_s(offset: usize, immOffset?: usize, immAlign?: usize): i32;\r\n  @builtin export declare function load16_u(offset: usize, immOffset?: usize, immAlign?: usize): i32;\r\n  @builtin export declare function load(offset: usize, immOffset?: usize, immAlign?: usize): i32;\r\n  @builtin export declare function store8(offset: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\r\n  @builtin export declare function store16(offset: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\r\n  @builtin export declare function store(offset: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\r\n  \r\n  export namespace atomic {\r\n    @builtin export declare function load8_u(offset: usize, immOffset?: usize): i32;\r\n    @builtin export declare function load16_u(offset: usize, immOffset?: usize): i32;\r\n    @builtin export declare function load(offset: usize, immOffset?: usize): i32;\r\n    @builtin export declare function store8(offset: usize, value: i32, immOffset?: usize): void;\r\n    @builtin export declare function store16(offset: usize, value: i32, immOffset?: usize): void;\r\n    @builtin export declare function store(offset: usize, value: i32, immOffset?: usize): void;\r\n    @builtin export declare function wait(ptr: usize, expected: i32, timeout: i64): AtomicWaitResult;\r\n    @builtin export declare function notify(ptr: usize, count: i32): i32;\r\n\r\n    export namespace rmw8 {\r\n      @builtin export declare function add_u(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function sub_u(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function and_u(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function or_u(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function xor_u(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function xchg_u(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function cmpxchg_u(offset: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\r\n    }\r\n    export namespace rmw16 {\r\n      @builtin export declare function add_u(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function sub_u(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function and_u(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function or_u(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function xor_u(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function xchg_u(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function cmpxchg_u(offset: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\r\n    }\r\n    export namespace rmw {\r\n      @builtin export declare function add(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function sub(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function and(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function or(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function xor(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function xchg(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function cmpxchg(offset: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\r\n    }\r\n  }\r\n}\r\n\r\n@builtin export declare function i64(value: void): i64;\r\nexport namespace i64 {\r\n  @lazy export const MIN_VALUE: i64 = -9223372036854775808;\r\n  @lazy export const MAX_VALUE: i64 =  9223372036854775807;\r\n  @builtin export declare function clz(value: i64): i64;\r\n  @builtin export declare function ctz(value: i64): i64;\r\n  @builtin export declare function load8_s(offset: usize, immOffset?: usize, immAlign?: usize): i64;\r\n  @builtin export declare function load8_u(offset: usize, immOffset?: usize, immAlign?: usize): i64;\r\n  @builtin export declare function load16_s(offset: usize, immOffset?: usize, immAlign?: usize): i64;\r\n  @builtin export declare function load16_u(offset: usize, immOffset?: usize, immAlign?: usize): i64;\r\n  @builtin export declare function load32_s(offset: usize, immOffset?: usize, immAlign?: usize): i64;\r\n  @builtin export declare function load32_u(offset: usize, immOffset?: usize, immAlign?: usize): i64;\r\n  @builtin export declare function load(offset: usize, immOffset?: usize): i64;\r\n  @builtin export declare function popcnt(value: i64): i64;\r\n  @builtin export declare function rotl(value: i64, shift: i64): i64;\r\n  @builtin export declare function rotr(value: i64, shift: i64): i64;\r\n  @builtin export declare function reinterpret_f64(value: f64): i64;\r\n  @builtin export declare function store8(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\r\n  @builtin export declare function store16(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\r\n  @builtin export declare function store32(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\r\n  @builtin export declare function store(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\r\n\r\n  export namespace atomic {\r\n    @builtin export declare function load8_u(offset: usize, immOffset?: usize): i64;\r\n    @builtin export declare function load16_u(offset: usize, immOffset?: usize): i64;\r\n    @builtin export declare function load32_u(offset: usize, immOffset?: usize): i64;\r\n    @builtin export declare function load(offset: usize, immOffset?: usize): i64;\r\n    @builtin export declare function store8(offset: usize, value: i64, immOffset?: usize): void;\r\n    @builtin export declare function store16(offset: usize, value: i64, immOffset?: usize): void;\r\n    @builtin export declare function store32(offset: usize, value: i64, immOffset?: usize): void;\r\n    @builtin export declare function store(offset: usize, value: i64, immOffset?: usize): void;\r\n    @builtin export declare function wait(ptr: usize, expected: i64, timeout: i64): AtomicWaitResult;\r\n    @builtin export declare function notify(ptr: usize, count: i32): i32;\r\n\r\n    export namespace rmw8 {\r\n      @builtin export declare function add_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function sub_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function and_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function or_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function xor_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function xchg_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function cmpxchg_u(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\r\n    }\r\n    export namespace rmw16 {\r\n      @builtin export declare function add_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function sub_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function and_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function or_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function xor_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function xchg_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function cmpxchg_u(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\r\n    }\r\n    export namespace rmw32 {\r\n      @builtin export declare function add_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function sub_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function and_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function or_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function xor_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function xchg_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function cmpxchg_u(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\r\n    }\r\n    export namespace rmw {\r\n      @builtin export declare function add(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function sub(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function and(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function or(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function xor(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function xchg(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function cmpxchg(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\r\n    }\r\n  }\r\n}\r\n\r\n@builtin export declare function isize(value: void): isize;\r\nexport namespace isize {\r\n  @lazy export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\r\n    ? -2147483648\r\n    : <isize>-9223372036854775808;\r\n  @lazy export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\r\n    ? 2147483647\r\n    : <isize>9223372036854775807;\r\n}\r\n\r\n@builtin export declare function u8(value: void): u8;\r\nexport namespace u8 {\r\n  @lazy export const MIN_VALUE: u8 = 0;\r\n  @lazy export const MAX_VALUE: u8 = 255;\r\n}\r\n\r\n@builtin export declare function u16(value: void): u16;\r\nexport namespace u16 {\r\n  @lazy export const MIN_VALUE: u16 = 0;\r\n  @lazy export const MAX_VALUE: u16 = 65535;\r\n}\r\n\r\n@builtin export declare function u32(value: void): u32;\r\nexport namespace u32 {\r\n  @lazy export const MIN_VALUE: u32 = 0;\r\n  @lazy export const MAX_VALUE: u32 = 4294967295;\r\n}\r\n\r\n@builtin export declare function u64(value: void): u64;\r\nexport namespace u64 {\r\n  @lazy export const MIN_VALUE: u64 = 0;\r\n  @lazy export const MAX_VALUE: u64 = 18446744073709551615;\r\n}\r\n\r\n@builtin export declare function usize(value: void): usize;\r\nexport namespace usize {\r\n  @lazy export const MIN_VALUE: usize = 0;\r\n  @lazy export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\r\n    ? 4294967295\r\n    : <usize>18446744073709551615;\r\n}\r\n\r\n@builtin export declare function bool(value: void): bool;\r\nexport namespace bool {\r\n  @lazy export const MIN_VALUE: bool = false;\r\n  @lazy export const MAX_VALUE: bool = true;\r\n}\r\n\r\n@builtin export declare function f32(value: void): f32;\r\nexport namespace f32 {\r\n  @lazy export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f\r\n  @lazy export const MIN_VALUE = reinterpret<f32>(0x00000001); // 0x0.000001p+0f\r\n  @lazy export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); // 0x1.fffffep+127f\r\n  @lazy export const MIN_NORMAL_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f\r\n  @lazy export const MIN_SAFE_INTEGER: f32 = -16777215;\r\n  @lazy export const MAX_SAFE_INTEGER: f32 =  16777215;\r\n  @builtin export declare function abs(value: f32): f32;\r\n  @builtin export declare function ceil(value: f32): f32;\r\n  @builtin export declare function copysign(x: f32, y: f32): f32;\r\n  @builtin export declare function floor(value: f32): f32;\r\n  @builtin export declare function load(offset: usize, immOffset?: usize, immAlign?: usize): f32;\r\n  @builtin export declare function max(left: f32, right: f32): f32;\r\n  @builtin export declare function min(left: f32, right: f32): f32;\r\n  @builtin export declare function nearest(value: f32): f32;\r\n  @builtin export declare function reinterpret_i32(value: i32): f32;\r\n  @builtin export declare function sqrt(value: f32): f32;\r\n  @builtin export declare function store(offset: usize, value: f32, immOffset?: usize, immAlign?: usize): void;\r\n  @builtin export declare function trunc(value: f32): f32;\r\n}\r\n\r\n@builtin export declare function f64(value: void): f64;\r\nexport namespace f64 {\r\n  @lazy export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52\r\n  @lazy export const MIN_VALUE = reinterpret<f64>(0x0000000000000001); // 0x0.0000000000001p+0\r\n  @lazy export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); // 0x1.fffffffffffffp+1023\r\n  @lazy export const MIN_NORMAL_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022\r\n  @lazy export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\r\n  @lazy export const MAX_SAFE_INTEGER: f64 =  9007199254740991;\r\n  @builtin export declare function abs(value: f64): f64;\r\n  @builtin export declare function ceil(value: f64): f64;\r\n  @builtin export declare function copysign(x: f64, y: f64): f64;\r\n  @builtin export declare function floor(value: f64): f64;\r\n  @builtin export declare function load(offset: usize, immOffset?: usize, immAlign?: usize): f64;\r\n  @builtin export declare function max(left: f64, right: f64): f64;\r\n  @builtin export declare function min(left: f64, right: f64): f64;\r\n  @builtin export declare function nearest(value: f64): f64;\r\n  @builtin export declare function reinterpret_i64(value: i64): f64;\r\n  @builtin export declare function sqrt(value: f64): f64;\r\n  @builtin export declare function store(offset: usize, value: f64, immOffset?: usize, immAlign?: usize): void;\r\n  @builtin export declare function trunc(value: f64): f64;\r\n}\r\n\r\n@builtin export declare function v128(a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8, i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8): v128;\r\nexport namespace v128 {\r\n  @builtin export declare function splat<T>(x: T): v128;\r\n  @builtin export declare function extract_lane<T>(x: v128, idx: u8): T;\r\n  @builtin export declare function replace_lane<T>(x: v128, idx: u8, value: T): v128;\r\n  @builtin export declare function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;\r\n  @builtin export declare function load(offset: usize, immOffset?: usize, immAlign?: usize): v128;\r\n  @builtin export declare function store(offset: usize, value: v128, immOffset?: usize, immAlign?: usize): void;\r\n  @builtin export declare function add<T>(a: v128, b: v128): v128;\r\n  @builtin export declare function sub<T>(a: v128, b: v128): v128;\r\n  @builtin export declare function mul<T>(a: v128, b: v128): v128; // except i64\r\n  @builtin export declare function div<T>(a: v128, b: v128): v128; // f32, f64 only\r\n  @builtin export declare function neg<T>(a: v128): v128;\r\n  @builtin export declare function add_saturate<T>(a: v128, b: v128): v128;\r\n  @builtin export declare function sub_saturate<T>(a: v128, b: v128): v128;\r\n  @builtin export declare function shl<T>(a: v128, b: i32): v128;\r\n  @builtin export declare function shr<T>(a: v128, b: i32): v128;\r\n  @builtin export declare function and(a: v128, b: v128): v128;\r\n  @builtin export declare function or(a: v128, b: v128): v128;\r\n  @builtin export declare function xor(a: v128, b: v128): v128;\r\n  @builtin export declare function not(a: v128): v128;\r\n  @builtin export declare function bitselect(v1: v128, v2: v128, c: v128): v128;\r\n  @builtin export declare function any_true<T>(a: v128): bool;\r\n  @builtin export declare function all_true<T>(a: v128): bool;\r\n  @builtin export declare function min<T>(a: v128, b: v128): v128; // f32, f64 only\r\n  @builtin export declare function max<T>(a: v128, b: v128): v128; // f32, f64 only\r\n  @builtin export declare function abs<T>(a: v128): v128; // f32, f64 only\r\n  @builtin export declare function sqrt<T>(a: v128): v128; // f32, f64 only\r\n  @builtin export declare function eq<T>(a: v128, b: v128): v128;\r\n  @builtin export declare function ne<T>(a: v128, b: v128): v128;\r\n  @builtin export declare function lt<T>(a: v128, b: v128): v128;\r\n  @builtin export declare function le<T>(a: v128, b: v128): v128;\r\n  @builtin export declare function gt<T>(a: v128, b: v128): v128;\r\n  @builtin export declare function ge<T>(a: v128, b: v128): v128;\r\n  @builtin export declare function convert<T>(a: v128): v128;\r\n  @builtin export declare function trunc<T>(a: v128): v128;\r\n}\r\n\r\n@builtin export declare function i8x16(a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8, i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8): v128;\r\nexport namespace i8x16 {\r\n  @builtin export declare function splat(x: i8): v128;\r\n  @builtin export declare function extract_lane_s(x: v128, idx: u8): i8;\r\n  @builtin export declare function extract_lane_u(x: v128, idx: u8): u8;\r\n  @builtin export declare function replace_lane(x: v128, idx: u8, value: i8): v128;\r\n  @builtin export declare function add(a: v128, b: v128): v128;\r\n  @builtin export declare function sub(a: v128, b: v128): v128;\r\n  @builtin export declare function mul(a: v128, b: v128): v128;\r\n  @builtin export declare function neg(a: v128): v128;\r\n  @builtin export declare function add_saturate_s(a: v128, b: v128): v128;\r\n  @builtin export declare function add_saturate_u(a: v128, b: v128): v128;\r\n  @builtin export declare function sub_saturate_s(a: v128, b: v128): v128;\r\n  @builtin export declare function sub_saturate_u(a: v128, b: v128): v128;\r\n  @builtin export declare function shl(a: v128, b: i32): v128;\r\n  @builtin export declare function shr_s(a: v128, b: i32): v128;\r\n  @builtin export declare function shr_u(a: v128, b: i32): v128;\r\n  @builtin export declare function any_true(a: v128): bool;\r\n  @builtin export declare function all_true(a: v128): bool;\r\n  @builtin export declare function eq(a: v128, b: v128): v128;\r\n  @builtin export declare function ne(a: v128, b: v128): v128;\r\n  @builtin export declare function lt_s(a: v128, b: v128): v128;\r\n  @builtin export declare function lt_u(a: v128, b: v128): v128;\r\n  @builtin export declare function le_s(a: v128, b: v128): v128;\r\n  @builtin export declare function le_u(a: v128, b: v128): v128;\r\n  @builtin export declare function gt_s(a: v128, b: v128): v128;\r\n  @builtin export declare function gt_u(a: v128, b: v128): v128;\r\n  @builtin export declare function ge_s(a: v128, b: v128): v128;\r\n  @builtin export declare function ge_u(a: v128, b: v128): v128;\r\n}\r\n\r\n@builtin export declare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;\r\nexport namespace i16x8 {\r\n  @builtin export declare function splat(x: i16): v128;\r\n  @builtin export declare function extract_lane_s(x: v128, idx: u8): i16;\r\n  @builtin export declare function extract_lane_u(x: v128, idx: u8): u16;\r\n  @builtin export declare function replace_lane(x: v128, idx: u8, value: i16): v128;\r\n  @builtin export declare function add(a: v128, b: v128): v128;\r\n  @builtin export declare function sub(a: v128, b: v128): v128;\r\n  @builtin export declare function mul(a: v128, b: v128): v128;\r\n  @builtin export declare function neg(a: v128): v128;\r\n  @builtin export declare function add_saturate_s(a: v128, b: v128): v128;\r\n  @builtin export declare function add_saturate_u(a: v128, b: v128): v128;\r\n  @builtin export declare function sub_saturate_s(a: v128, b: v128): v128;\r\n  @builtin export declare function sub_saturate_u(a: v128, b: v128): v128;\r\n  @builtin export declare function shl(a: v128, b: i32): v128;\r\n  @builtin export declare function shr_s(a: v128, b: i32): v128;\r\n  @builtin export declare function shr_u(a: v128, b: i32): v128;\r\n  @builtin export declare function any_true(a: v128): bool;\r\n  @builtin export declare function all_true(a: v128): bool;\r\n  @builtin export declare function eq(a: v128, b: v128): v128;\r\n  @builtin export declare function ne(a: v128, b: v128): v128;\r\n  @builtin export declare function lt_s(a: v128, b: v128): v128;\r\n  @builtin export declare function lt_u(a: v128, b: v128): v128;\r\n  @builtin export declare function le_s(a: v128, b: v128): v128;\r\n  @builtin export declare function le_u(a: v128, b: v128): v128;\r\n  @builtin export declare function gt_s(a: v128, b: v128): v128;\r\n  @builtin export declare function gt_u(a: v128, b: v128): v128;\r\n  @builtin export declare function ge_s(a: v128, b: v128): v128;\r\n  @builtin export declare function ge_u(a: v128, b: v128): v128;\r\n}\r\n\r\n@builtin export declare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;\r\nexport namespace i32x4 {\r\n  @builtin export declare function splat(x: i32): v128;\r\n  @builtin export declare function extract_lane(x: v128, idx: u8): i32;\r\n  @builtin export declare function replace_lane(x: v128, idx: u8, value: i32): v128;\r\n  @builtin export declare function add(a: v128, b: v128): v128;\r\n  @builtin export declare function sub(a: v128, b: v128): v128;\r\n  @builtin export declare function mul(a: v128, b: v128): v128;\r\n  @builtin export declare function neg(a: v128): v128;\r\n  @builtin export declare function shl(a: v128, b: i32): v128;\r\n  @builtin export declare function shr_s(a: v128, b: i32): v128;\r\n  @builtin export declare function shr_u(a: v128, b: i32): v128;\r\n  @builtin export declare function any_true(a: v128): bool;\r\n  @builtin export declare function all_true(a: v128): bool;\r\n  @builtin export declare function eq(a: v128, b: v128): v128;\r\n  @builtin export declare function ne(a: v128, b: v128): v128;\r\n  @builtin export declare function lt_s(a: v128, b: v128): v128;\r\n  @builtin export declare function lt_u(a: v128, b: v128): v128;\r\n  @builtin export declare function le_s(a: v128, b: v128): v128;\r\n  @builtin export declare function le_u(a: v128, b: v128): v128;\r\n  @builtin export declare function gt_s(a: v128, b: v128): v128;\r\n  @builtin export declare function gt_u(a: v128, b: v128): v128;\r\n  @builtin export declare function ge_s(a: v128, b: v128): v128;\r\n  @builtin export declare function ge_u(a: v128, b: v128): v128;\r\n  @builtin export declare function trunc_s_f32x4_sat(a: v128): v128;\r\n  @builtin export declare function trunc_u_f32x4_sat(a: v128): v128;\r\n}\r\n\r\n@builtin export declare function i64x2(a: i64, b: i64): v128;\r\nexport namespace i64x2 {\r\n  @builtin export declare function splat(x: i64): v128;\r\n  @builtin export declare function extract_lane(x: v128, idx: u8): i64;\r\n  @builtin export declare function replace_lane(x: v128, idx: u8, value: i64): v128;\r\n  @builtin export declare function add(a: v128, b: v128): v128;\r\n  @builtin export declare function sub(a: v128, b: v128): v128;\r\n  @builtin export declare function mul(a: v128, b: v128): v128;\r\n  @builtin export declare function neg(a: v128): v128;\r\n  @builtin export declare function shl(a: v128, b: i32): v128;\r\n  @builtin export declare function shr_s(a: v128, b: i32): v128;\r\n  @builtin export declare function shr_u(a: v128, b: i32): v128;\r\n  @builtin export declare function any_true(a: v128): bool;\r\n  @builtin export declare function all_true(a: v128): bool;\r\n  @builtin export declare function trunc_s_f64x2_sat(a: v128): v128;\r\n  @builtin export declare function trunc_u_f64x2_sat(a: v128): v128;\r\n}\r\n\r\n@builtin export declare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;\r\nexport namespace f32x4 {\r\n  @builtin export declare function splat(x: f32): v128;\r\n  @builtin export declare function extract_lane(x: v128, idx: u8): f32;\r\n  @builtin export declare function replace_lane(x: v128, idx: u8, value: f32): v128;\r\n  @builtin export declare function add(a: v128, b: v128): v128;\r\n  @builtin export declare function sub(a: v128, b: v128): v128;\r\n  @builtin export declare function mul(a: v128, b: v128): v128;\r\n  @builtin export declare function div(a: v128, b: v128): v128;\r\n  @builtin export declare function neg(a: v128): v128;\r\n  @builtin export declare function min(a: v128, b: v128): v128;\r\n  @builtin export declare function max(a: v128, b: v128): v128;\r\n  @builtin export declare function abs(a: v128): v128;\r\n  @builtin export declare function sqrt(a: v128): v128;\r\n  @builtin export declare function eq(a: v128, b: v128): v128;\r\n  @builtin export declare function ne(a: v128, b: v128): v128;\r\n  @builtin export declare function lt(a: v128, b: v128): v128;\r\n  @builtin export declare function le(a: v128, b: v128): v128;\r\n  @builtin export declare function gt(a: v128, b: v128): v128;\r\n  @builtin export declare function ge(a: v128, b: v128): v128;\r\n  @builtin export declare function convert_s_i32x4(a: v128): v128;\r\n  @builtin export declare function convert_u_i32x4(a: v128): v128;\r\n}\r\n\r\n@builtin export declare function f64x2(a: f64, b: f64): v128;\r\nexport namespace f64x2 {\r\n  @builtin export declare function splat(x: f64): v128;\r\n  @builtin export declare function extract_lane(x: v128, idx: u8): f64;\r\n  @builtin export declare function replace_lane(x: v128, idx: u8, value: f64): v128;\r\n  @builtin export declare function add(a: v128, b: v128): v128;\r\n  @builtin export declare function sub(a: v128, b: v128): v128;\r\n  @builtin export declare function mul(a: v128, b: v128): v128;\r\n  @builtin export declare function div(a: v128, b: v128): v128;\r\n  @builtin export declare function neg(a: v128): v128;\r\n  @builtin export declare function min(a: v128, b: v128): v128;\r\n  @builtin export declare function max(a: v128, b: v128): v128;\r\n  @builtin export declare function abs(a: v128): v128;\r\n  @builtin export declare function sqrt(a: v128): v128;\r\n  @builtin export declare function eq(a: v128, b: v128): v128;\r\n  @builtin export declare function ne(a: v128, b: v128): v128;\r\n  @builtin export declare function lt(a: v128, b: v128): v128;\r\n  @builtin export declare function le(a: v128, b: v128): v128;\r\n  @builtin export declare function gt(a: v128, b: v128): v128;\r\n  @builtin export declare function ge(a: v128, b: v128): v128;\r\n  @builtin export declare function convert_s_i64x2(a: v128): v128;\r\n  @builtin export declare function convert_u_i64x2(a: v128): v128;\r\n}\r\n\r\nexport namespace v8x16 {\r\n  @builtin export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8, l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8): v128;\r\n}\r\n\r\n@builtin export declare function start(): void;\r\n"]}